"use strict";(self.webpackChunkvesta_docs=self.webpackChunkvesta_docs||[]).push([[480],{7050:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(6687);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=l(n),h=o,m=d["".concat(c,".").concat(h)]||d[h]||p[h]||r;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4980:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(557),o=(n(6687),n(7050));const r={sidebar_position:1},i="Building Smart Contracts",s={unversionedId:"contracts/contracts",id:"contracts/contracts",title:"Building Smart Contracts",description:"For this demonstration we will be building 721.js, a simplified NFT contract based on the ERC721 standard.",source:"@site/docs/3-contracts/contracts.md",sourceDirName:"3-contracts",slug:"/contracts/contracts",permalink:"/docs/contracts/contracts",draft:!1,editUrl:"https://github.com/VestaProtocol/vesta/docs/3-contracts/contracts.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Vesta Tokenomics",permalink:"/docs/econ/econmodel"},next:{title:"Contract Details",permalink:"/docs/contracts/details"}},c={},l=[{value:"Contract Structure",id:"contract-structure",level:2}],u={toc:l},d="wrapper";function p(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"building-smart-contracts"},"Building Smart Contracts"),(0,o.kt)("p",null,"For this demonstration we will be building ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/VestaProtocol/vesta/blob/master/examples/721.js"},"721.js"),", a simplified NFT contract based on the ERC721 standard."),(0,o.kt)("h2",{id:"contract-structure"},"Contract Structure"),(0,o.kt)("p",null,"Smart contracts on Vesta are split into a few major parts, the first and most important being the ",(0,o.kt)("inlineCode",{parentName:"p"},"CONTRACT")," object. This object is responsible for exposing functions and queries to both the user, and other contracts, as well as handling initialization."),(0,o.kt)("p",null,"For this NFT contract we want two main functions, the ability to Mint tokens, and send them to new owners. We also want to be able to view the contracts data in an organized way. We can handle the minting and transferring with two functions as so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"CONTRACT.functions.transfer = function(token_id, to) {}\n\nCONTRACT.functions.mint = function() {}\n")),(0,o.kt)("p",null,"As you can see, we create two new functions as fields of the ",(0,o.kt)("inlineCode",{parentName:"p"},"functions")," object on the ",(0,o.kt)("inlineCode",{parentName:"p"},"CONTRACT")," object, this allows users/contracts to call these functions."),(0,o.kt)("p",null,"Because this is an NFT we want to store a list of tokens & respective owners, their metadata URL, the cost of minting a token, how many tokens are allowed to be minted/how many are already minted. We can do this with the ",(0,o.kt)("inlineCode",{parentName:"p"},"STD.read")," & ",(0,o.kt)("inlineCode",{parentName:"p"},"STD.write")," functions from the Roma Standard Library. All data saved in Vesta Smart Contracts is done through a Key-Value store. We will create a series of constant strings to be used as store keys."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const KEY_URL = "url"\nconst KEY_NAME = "name"\nconst KEY_TOKEN_ID = "token_id"\nconst KEY_COST = "cost"\nconst KEY_MAX = "MAX"\nconst KEY_COUNTER = "COUNTER"\n\nCONTRACT.functions.transfer = function(token_id, to) {}\n\nCONTRACT.functions.mint = function() {}\n')),(0,o.kt)("p",null,"Now that we have the keys mapped out, let's implement some logic to handle the minting of the tokens."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'CONTRACT.functions.mint = function() {\n    let count = parseInt(STD.read(KEY_COUNTER))\n\n    let max_tokens = parseInt(STD.read(KEY_MAX))\n\n    if (max_tokens < count + 1) {\n        STD.panic("too many minted already")\n    }\n\n    let cost = STD.read(KEY_COST)\n    let ok = STD.bank.sendTokens(CONTRACT.address, cost)\n    if (!ok) {\n        STD.panic("not enough balance of " + cost)\n    }\n\n    STD.write(KEY_COUNTER, count + 1)\n\n    STD.write(count, CTX.sender)\n}\n')),(0,o.kt)("p",null,"As you can see we are reading the counter value and parsing it into an integer value, this is because every value saved to the store is saved as a string, so numbers must be parsed to avoid potential implicit type conversions."),(0,o.kt)("p",null,"Once we verify that there are enough tokens left to mint, we attempt to take the price of the tokens from the user, this is done through the ",(0,o.kt)("inlineCode",{parentName:"p"},"STD.bank")," object. This object is an injection created by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/VestaProtocol/roma/tree/master/vminjects/bank"},"Roma's Bank Inject"),"."),(0,o.kt)("p",null,"If the user can't send the tokens, the process will fail and the transaction will be reverted. However, if the user has the required balance, the new token ID is saved to the KV store with the users address as the value to indicate they are now the owner. Lastly, the counter is incremented."),(0,o.kt)("p",null,"We can then go ahead and do the same for the transfer function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'CONTRACT.functions.transfer = function(token_id, to) {\n    let count = parseInt(STD.read(KEY_COUNTER))\n\n    if (parseInt(token_id) > count) {\n        STD.panic("no token with that id exists")\n    }\n\n    let owner = STD.read(token_id)\n\n    if (owner !== CTX.sender) {\n        STD.panic("you do not own this token")\n    }\n\n    STD.write(parseInt(token_id), to)\n}\n')),(0,o.kt)("p",null,"This is great and all, but now how do we see any of the information? Sure we could check the raw KV store, but that would be awful. Instead, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"queries")," object from the ",(0,o.kt)("inlineCode",{parentName:"p"},"CONTRACT")," object. Let's take a look at creating a query that returns the information about the contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"CONTRACT.queries.info = function() {\n    let url = STD.read(KEY_URL)\n    let name = STD.read(KEY_NAME)\n    let tokenid = STD.read(KEY_TOKEN_ID)\n    let max = STD.read(KEY_MAX)\n    let cost = STD.read(KEY_COST)\n\n    let count = STD.read(KEY_COUNTER)\n\n    return JSON.stringify({\n        url: url,\n        name: name,\n        token_id: tokenid,\n        max: max,\n        minted: count,\n        price: cost,\n    })\n}\n")),(0,o.kt)("p",null,"We can see that this query is reading the information form the keys we laid out earlier and presenting them in a JSON response."),(0,o.kt)("p",null,"We can also create a query to get similar information but for a single token."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'CONTRACT.queries.get = function(token_id) {\n    let count = parseInt(STD.read(KEY_COUNTER))\n\n    if (parseInt(token_id) >= count) {\n        STD.panic("no token with that id exists")\n    }\n\n    let owner = STD.read(token_id)\n\n    let url = STD.read(KEY_URL) + token_id\n\n    return JSON.stringify({\n        url: url,\n        token_id: token_id,\n        owner: owner,\n    })\n}\n')),(0,o.kt)("p",null,"This time we read the token data from a token ID input, and return the owner or panic if the token can't be found."),(0,o.kt)("p",null,"Finally, you may be wondering how the URL field contains anything since we haven't written anything to it yet. For this we fall back to the initialization of the contract. Every contract has a field called ",(0,o.kt)("inlineCode",{parentName:"p"},"init")," which contains a function that gets called when the contract is first instantiated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'CONTRACT.init = function(name, tokenid, url, cost, max) {\n    STD.write(KEY_URL, url)\n    STD.write(KEY_NAME, name)\n    STD.write(KEY_TOKEN_ID, tokenid)\n    STD.write(KEY_COST, cost)\n    STD.write(KEY_MAX, max)\n    STD.write(KEY_COUNTER, "0")\n}\n')),(0,o.kt)("p",null,"Here you can see that we initialize the contract with fields send from the user upon initialization. This allows developers to instantiate multiple contracts with the same source code without needing to re-upload it."),(0,o.kt)("p",null,"And finally we can save this complete file as ",(0,o.kt)("inlineCode",{parentName:"p"},"721.js")," and upload it to the chain like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'vestad tx vm upload 721.js --from {account} # this example we will consider this the first code uploaded, slot 0\n\nvestad tx vm instantiate NFT {contract index} "NFT,nft,http://localhost/nft_metadata,10stake,20" --from {account}\n')),(0,o.kt)("p",null,"This creates a contract called NFT with the ticker nft, a price of 10 Stake, and a max supply of 20."),(0,o.kt)("p",null,"You can then mint a token by running:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'vestad tx vm execute NFT mint "" --from {account}\n')),(0,o.kt)("p",null,"This should succeed given that you have 10 Stake on that account, you can check the token now with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"vestad q vm query NFT get 0\n")),(0,o.kt)("p",null,"This should return the token information expressed in the ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," function we wrote earlier."),(0,o.kt)("p",null,"And that's it, you have now created a simple NFT contract on Vesta in Javascript!"))}p.isMDXComponent=!0}}]);