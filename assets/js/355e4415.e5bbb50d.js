"use strict";(self.webpackChunkvesta_docs=self.webpackChunkvesta_docs||[]).push([[636],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),f=r,h=d["".concat(l,".").concat(f)]||d[f]||u[f]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},5473:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:3},i="NFT Marketplace",s={unversionedId:"contracts/marketplace",id:"contracts/marketplace",title:"NFT Marketplace",description:"In this overview, we will be building both a better NFT contract as well as a marketplace to facilitate the listing and",source:"@site/docs/3-contracts/3-marketplace.md",sourceDirName:"3-contracts",slug:"/contracts/marketplace",permalink:"/docs/contracts/marketplace",draft:!1,editUrl:"https://github.com/VestaProtocol/vesta/tree/master/assets/vesta-docs/docs/3-contracts/3-marketplace.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Contract Details",permalink:"/docs/contracts/details"},next:{title:"Building an Atomic Swap",permalink:"/docs/contracts/atomicswap"}},l={},c=[{value:"The NFT Standard",id:"the-nft-standard",level:2},{value:"Data Structures",id:"data-structures",level:3},{value:"Minting",id:"minting",level:3},{value:"Transfers",id:"transfers",level:3},{value:"Approvals",id:"approvals",level:3},{value:"The Marketplace",id:"the-marketplace",level:2},{value:"Listings",id:"listings",level:3},{value:"Buying",id:"buying",level:3}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"nft-marketplace"},"NFT Marketplace"),(0,r.kt)("p",null,"In this overview, we will be building both a better NFT contract as well as a marketplace to facilitate the listing and\nsale of these NFTs. The best part about this marketplace is that it will work for any NFT deployed within a specification\nof contracts, but we'll get to that later."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Please do not use any of these contracts in a production environment, they are meant only as education tools and are\nfor sure riddled with security vulnerabilities and exploits. You have been warned.")),(0,r.kt)("h2",{id:"the-nft-standard"},"The NFT Standard"),(0,r.kt)("p",null,"For this example, we will be using ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/VestaProtocol/vesta/blob/master/examples/nft.js"},"this NFT contract"),"."),(0,r.kt)("h3",{id:"data-structures"},"Data Structures"),(0,r.kt)("p",null,"In this contract, we will have a counter that increments the IDs of each minted NFT as well as the NFTs themselves. We\nstore NFTs as a JSON object, this will allow us to save as much or as little information in each token as we want."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function getCount() {\n    let s = STD.read(COUNTER)\n    if (s == null) {\n        return 0\n    }\n    return parseInt(s)\n}\n\nfunction incrementCount() {\n    let count = getCount()\n    STD.write(COUNTER, count + 1)\n}\n\nfunction Token(id, owner, data) {\n    return {\n        id: id,\n        owner: owner,\n        data: data,\n        approvals: [],\n    }\n}\n")),(0,r.kt)("h3",{id:"minting"},"Minting"),(0,r.kt)("p",null,"To be able to mint a token, it looks a lot like our last NFT example, we check if there are any left, and if the user has\nthe tokens to pay for the mint, if so, we mint a new token."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'CONTRACT.functions.mint = function() {\n    let currentCount = getCount()\n    if (currentCount >= getMaxTokens()) {\n        STD.panic("can\'t mint anymore tokens")\n    }\n\n    let token = Token(currentCount, CTX.sender, "nft data")\n\n    let cost = getPrice()\n    let ok = STD.bank.sendTokens(CONTRACT.address, cost)\n    if (!ok) {\n        STD.panic("not enough balance of " + cost)\n    }\n\n    SaveToken(token)\n    incrementCount()\n}\n')),(0,r.kt)("h3",{id:"transfers"},"Transfers"),(0,r.kt)("p",null,"Here we deviate from the previous NFT contract, in this case we don't only check if the user is the owner before\nauthorizing the transfer. We now also check the list of authorizations to see if the user has been authorized by the\nowner to act on their behalf."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'CONTRACT.functions.transfer = function(id, receiver) {\n    let token = LoadToken(id)\n\n    if (token.owner !== CTX.sender) {\n        let found = false\n        for (const apr of token.approvals) {\n            if (apr === CTX.sender) {\n                found = true\n                break\n            }\n        }\n        if (!found) {\n            STD.panic("cannot transfer token that isn\'t yours!")\n        }\n    }\n    token.approvals = []\n    token.owner = receiver\n    SaveToken(token)\n    return true\n}\n')),(0,r.kt)("h3",{id:"approvals"},"Approvals"),(0,r.kt)("p",null,"And finally, we need to add a way for a user to add someone to the list of approvals."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'CONTRACT.functions.add_approval = function(id, approval) {\n    let token = LoadToken(id)\n\n    if (token.owner !== CTX.sender) {\n        STD.panic("cannot transfer token that isn\'t yours!")\n    }\n\n    token.approvals.push(approval)\n    SaveToken(token)\n\n    return true\n}\n')),(0,r.kt)("h2",{id:"the-marketplace"},"The Marketplace"),(0,r.kt)("p",null,"Now that we have an NFT with an approval list, we can build a marketplace dedicated to the buying and selling of these\nNFTs. Because every NFT created with this contract will have a ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer")," and an ",(0,r.kt)("inlineCode",{parentName:"p"},"add_approval")," function, we can make\nthe marketplace generic and work with any NFT contract."),(0,r.kt)("p",null,"For this example, we will be using ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/VestaProtocol/vesta/blob/master/examples/nft_marketplace.js"},"this Marketplace contract"),"."),(0,r.kt)("h3",{id:"listings"},"Listings"),(0,r.kt)("p",null,"Analyzing what is needed to hold the information about a listing, we can see that we create an ID from the other data\nfields and some hashing. Focusing more on the data itself, we have a ",(0,r.kt)("inlineCode",{parentName:"p"},"creator")," to hold who is selling the NFT, a\n",(0,r.kt)("inlineCode",{parentName:"p"},"contract")," field to keep track of which NFT contract we are creating the listing for, a ",(0,r.kt)("inlineCode",{parentName:"p"},"token")," field to keep track of\nwhich token ID from the contract we are selling. Lastly, we have a price field to keep track of the asking price for the\nsale."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function Listing(creator, contract, id, price) {\n    let listingId = STD.crypto.sha256(creator + contract + id + price)\n    return {\n        id: listingId,\n        creator: creator,\n        contract: contract,\n        token: id,\n        price: price,\n    }\n}\n")),(0,r.kt)("p",null,"To create a listing, we use the newly configured ",(0,r.kt)("inlineCode",{parentName:"p"},"add_approval")," function to give our marketplace contract the ability to\ntransfer an NFT that the seller owns. To do so we call the ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch")," function from Roma's standard library with a type of\n",(0,r.kt)("inlineCode",{parentName:"p"},"FORWARD")," to indicate we are transacting on the user's behalf. We create the listing and add an approval to the token,\nand voil\xe0! A listing is born."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'CONTRACT.functions.list = function(contract, token, price) {\n    let listing = Listing(CTX.sender, contract, parseInt(token), price)\n    SaveListing(listing)\n    let res = STD.fetch(contract, "add_approval", STD.FORWARD, token, CONTRACT.address)\n    if (res !== "true") {\n        STD.panic("failed to add approval for token " + token + " on " + contract + "(" + CONTRACT.address + ")\\nFull Log: " + JSON.stringify(res))\n    }\n}\n')),(0,r.kt)("h3",{id:"buying"},"Buying"),(0,r.kt)("p",null,"Now that we have the ability to sell NFTs, we need to match that with the ability to buy them. To do so, we first attempt\nto transfer the token specified in the listing to the user. If we are unable to do so it is because the marketplace is\nnot approved. Then we send the price of the token to the seller, if all goes well, we have swapped an NFT for a fee all\nwithout ever acting as an escrow account."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'CONTRACT.functions.buy = function(id) {\n    let listing = LoadListing(id)\n\n    let res = STD.fetch(listing.contract, "transfer", STD.POST, listing.token, CTX.sender)\n    if (res !== "true") {\n        STD.panic("failed to transfer token " + listing.token + " on " + listing.contract + "(" + CONTRACT.address + ")\\nFull Log: " + JSON.stringify(res))\n    }\n\n    let ok = STD.bank.sendTokens(CONTRACT.address, listing.price)\n    if (!ok) {\n        STD.panic("not enough balance of " + listing.price)\n    }\n\n    ok = STD.bank.withdrawTokens(listing.creator, listing.price)\n    if (!ok) {\n        STD.panic("not enough balance of " + listing.price)\n    }\n\n    RemoveListing(listing.id)\n}\n')))}u.isMDXComponent=!0}}]);